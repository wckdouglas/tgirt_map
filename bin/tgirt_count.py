#!/bin/env  python
# This is the pair-end pipeline for tgirt sequencing
# Mapping with hisat + bowtie local
# and extract tRNA reads for reassigning counts


from __future__ import division, print_function
import time
import glob
import argparse
import sys
from tgirt_map.mapping_tools import sample_object
from tgirt_map.table_tools import make_table
import tgirt_map
import os
import pkg_resources

def mapper_args(parser):
    parser.add_argument('-1', '--fastq1', 
              help = 'pairedEnd fastq file (read1)', required=True)
    parser.add_argument('-2', '--fastq2', 
              help = 'pairedEnd fastq file (read2)', required=True)
    parser.add_argument('-o','--outdir', 
              help = 'result directory that all resulting/intermediate files will be stored\n' + \
                                         'will create 1. $resultpath/trimmed\n' + \
                                         '            2. $resultpath/hisat\n'  + \
                                         '            3. $resultpath/bowtie2\n' + \
                                         '            4. $resultpath/mergeBam (all useful result files)\n',
                        required=True)
    parser.add_argument('--samplename', required=True,  
              help = 'samplename to use')
    parser.add_argument('--hisat_index', 
              help = 'hisat2 index', required=True)
    parser.add_argument('--bowtie2_index', 
              help = 'bowtie2 index', required=True)
    parser.add_argument('--univec_index', 
              help = 'bowtie2 index for univec sequences', required=True)
    parser.add_argument('--smRNA_index', 
              help = 'bowtie2 index for small RNA sequences', required=True)
    parser.add_argument('--bedpath', 
              help = 'bed folder for gene counting', required=True)
    parser.add_argument('--splicesite', 
              help = 'splice site file generated by hisat', required=True)
    parser.add_argument('--rRNA_mt_index' , 
              help = 'bowtie2 index for rRNA and tRNA combined', required=True)
    parser.add_argument('-p', '--threads', default=3, type=int, 
              help = 'number of cores to be used for the pipeline (at least 3, default: 3)')
    parser.add_argument('--TTN', action='store_true',  
              help = 'used TTN primer')
    parser.add_argument('--novel_splice', action='store_true',  
              help = 'Tweak hisat2 to enable more novel splicings')
    parser.add_argument('--trim_aggressive', action='store_true',  
              help = 'trim all R2R to R2R junction')
    parser.add_argument('--polyA', action='store_true',  
              help = 'trim for polyA/T')
    parser.add_argument('--umi', default=0, type=int,
              help = "Number of UMI bases from 5' of R1 (default = 0)")
    parser.add_argument('--multi', default=10, type=int,
              help = "Number of multimap alignments to report (default = 10)")
    parser.add_argument('--count_all', action='store_true',
              help = "Ignore UMI for counting, only evaluated with --umi option")
    parser.add_argument('--repeats', default=None,
              help = "Repeat mask BED file, recount repeat masks if a BED file is given (default: null)")
    parser.add_argument('--repeats_index', default=None,
              help = "Bowtie2 index of repeat mask fasta file (default: null)")
    parser.add_argument('--rerun', action='store_true', help = "Rerun existing files")
    parser.add_argument('--dry', action='store_true', help = "DEBUG: Dry run")
#    parser.add_argument('--skip_trim', action='store_true',  
#              help = 'DEBUG: skip trimming')
#    parser.add_argument('--skip_univec', action='store_true',  
#              help = 'DEBUG: skip univec filter')
#    parser.add_argument('--skip_smRNA', action='store_true',  
#              help = 'DEBUG: skip smallRNA filter')
#    parser.add_argument('--skip_premap', action='store_true',  
#              help = 'DEBUG: skip premapping tRNA and rRNA')
#    parser.add_argument('--skip_hisat', action='store_true',  
#              help = 'DEBUG: skip hisat')
#    parser.add_argument('--skip_bowtie', action='store_true',  
#              help = 'DEBUG: skip bowtie')
#    parser.add_argument('--skip_post_process_bam', action='store_true',  
#              help = 'DEBUG: skip combining BAM, multimap reassignment and BED file conversion')
#    parser.add_argument('--skip_remap', action='store_true',  
#              help = 'DEBUG: skip tRNA/rRNA remapping')
#    parser.add_argument('--skip_count', action='store_true',  
#              help = 'DEBUG: skip counting')
#    parser.add_argument('--snakemake', action = 'store_true',
#            help = 'Use snakemake workflow (DEBUG options unvailable)')
#    parser.add_argument('--fastp', action = 'store_true',
#            help = 'Use fastp for trimming (only work with snakemake)')
    #parser.add_argument('--hisat2', default='hisat2',  
    #          help = "PATH to Douglas's version of HISAT2, to allow dovetails")

def table_args(parser):
    parser.add_argument('-i', '--project_path', help = 'TGIRT map output folder', required=True)


def getopt():
    parser = argparse.ArgumentParser(prog=os.path.basename(sys.argv[0]),
                        description='Pipeline for mapping and counting for TGIRT-seq paired end data')
    subparsers = parser.add_subparsers(help='Command for TGIRT-map',
                        dest='subcommand')
    subparsers.required = True

    # mappign subparser
    mapping = subparsers.add_parser("map", 
                            help = "do TGIRT mapping and count")
    mapper_args(mapping)
    
    # table subparser
    table_tool = subparsers.add_parser("count", 
                            help = "make count table")
    table_args(table_tool)
    return parser.parse_args()

def snake_map(args):

    snakefile_dir = pkg_resources.resource_filename('tgirt_map', 'snakemake')
    force = ''
    if args.rerun:
        force = '-F'
    options = 'snakemake -s {}/tgirt_map.smk {} -p -j 24 --config '.format(snakefile_dir, force)
    for key, value in vars(args).items():
        if key != "subcommand":
            if not value:
                value = 0
            elif value == True:
                value = 1

            options += '{}={} '.format(key, value) 

    print (options)
    if not args.dry:
        os.system(options)
    else:
        os.system(options + ' -n ')


def tgirtmap(args):
    programname = sys.argv[0]
    start = time.time()

    process_sample = sample_object(args)

    process_sample.make_result_dir()

    if not args.skip_trim:
        process_sample.trimming()

    if args.univec_index:
        if not args.skip_univec:
            process_sample.RNA_filter(RNA='univec')
        process_sample.trimed1, process_sample.trimed2 = process_sample.filtered_fq1, process_sample.filtered_fq2

    if args.rRNA_mt_index:
        if not args.skip_premap:
            process_sample.RNA_filter(RNA='rRNA_mt')
        process_sample.trimed1, process_sample.trimed2 = process_sample.filtered_fq1, process_sample.filtered_fq2

    if args.smRNA_index:
        if not args.skip_smRNA:
            process_sample.RNA_filter(RNA='smallRNA')
        process_sample.trimed1, process_sample.trimed2 = process_sample.filtered_fq1, process_sample.filtered_fq2


    if not args.skip_hisat:
        process_sample.hisat_map()

    if not args.skip_bowtie:
        process_sample.bowtie_map()

    if not args.skip_post_process_bam:
        process_sample.combined_aligned()

        if args.umi > 0 and not args.count_all:
            process_sample.dedup_bam()

    if not args.skip_remap:
        process_sample.combined_filter()
        process_sample.make_alignment_bed()

    if not args.skip_count:
        process_sample.generate_all_count()
        if args.repeats and args.repeats_index:
            process_sample.generate_repeat_count()


    end = time.time()
    usedTime = end - start
    print('Finished: %s in %.3f hr\n' %(process_sample.samplename ,usedTime/3600), file=sys.stderr)
    return 0

def main():
    args = getopt()
    if args.subcommand == 'map':
#        if args.snakemake:
        snake_map(args)
#        else:
#            tgirtmap(args)
    
    elif args.subcommand == 'count':
        make_table(args.project_path)



if __name__ == '__main__':
    main()
